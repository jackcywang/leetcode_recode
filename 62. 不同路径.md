### 题目
[链接](https://leetcode-cn.com/problems/unique-paths/)
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？

示例 1:
>输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

示例2:
>输入: m = 7, n = 3
输出: 28

提示：
>1 <= m, n <= 100
题目数据保证答案小于等于 2 * 10 ^ 9

思路:使用动态规划的算法来解决该问题
动态规划问题的解决需要由三个步骤:
1.定义数组,确定数组中元素的含义,我们需要把问题的求解抽象成数组元素的求解,如这里可以将二维数组dp[i][j]定义为机器人走到矩阵框中中第(i,j)个格子总共有多少种走法

2,定义数组之间的关系,说白了,动态规划问题归根结底从问题信息中找到这个动态规划方程.求得数组中每个元素的值,最后求得最终结果,如本问题就是求dp[m-1][n-1]

这里以dp[i,j]为例,由于机器人只能往右或往下走一步,所以dp[i][j]的结果其实就是dp[i-1][j]和dp[i][j-1]的和,所以我们找到了动态规划方程
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```
我们需要遍历数组,计算数组中每个元素的值,然后求得dp[m-1][n-1]

3.找出边界条件,也就是这个方程的初始条件,以本题为例;我们知道机器人只能往右或往下走一个,那么对于图中的第0行,也就是dp[0][1:n-1]中的每个格子,它都只有一种走法,机器人都往右走,同样的第0列,也就是dp[1:n-1][0]中的每个格子,它也只有一种走法,对应的数组的初始化上,第0行和第0列都要初始化为1。

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> arr(m,vector<int>(n,0));
        for(int i=0;i<m;i++){
            arr[i][0] = 1;
        }
        for(int i=0;i<n;i++){
            arr[0][i] = 1;
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                arr[i][j] = arr[i-1][j]+arr[i][j-1];
            }
        }
        return arr[m-1][n-1];
    }
};
```

